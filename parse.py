#!/usr/bin/env python2.6

from Token import Token
from elementtree import SimpleXMLTreeBuilder
from util import error_if, JoosSyntaxException, Testing
from elementtree import ElementTree
import lexer
import weed
import simplify
import sys
from xml.sax.saxutils import escape
import elementtree as et

ElementTree.XMLTreeBuilder = SimpleXMLTreeBuilder.TreeBuilder


def load_parse_table(stream):
    """Reads parse table and returns all shift/reduce rules. """
    reduce_rules = []
    shift_rules = {}

    for _ in range(0, 2):
        skip = int(stream.readline())
        for _ in range(0, skip):
            stream.readline()
    stream.readline()
    num_expansions = int(stream.readline())

    for _ in range(0, num_expansions):
        rule = stream.readline().rstrip().split(" ")
        reduce_rules += [rule]
    stream.readline()
    num_rules = int(stream.readline())

    for _ in range(0, num_rules):
        tokens = stream.readline().split(" ")
        shift_rules[int(tokens[0]), tokens[1]] = (tokens[2], int(tokens[3]))
    return shift_rules, reduce_rules


shift_rules_, reduce_rules_ = load_parse_table(open("working.lr1"))


def parse_token_list(tokens):
    """Returns a parse tree of a list of tokens.  Uses LR(1) tree-building
       algorithm from the parsing handout.
       Input: stream: a stream to the parse table.
              tokens: a list of tokens
       Returns: a parse tree of the tokens"""
    stateStack = [0]
    nodeStack = []
    for a in tokens:
        a_ = a.type
        error_if(not (stateStack[-1], a_) in shift_rules_,
              "Parse error at token " + a.__str__())

        while "reduce" == shift_rules_[stateStack[-1], a_][0]:
            A = reduce_rules_[shift_rules_[stateStack[-1], a_][1]][0]
            y = reduce_rules_[shift_rules_[stateStack[-1], a_][1]][1:]
            child_nodes = []

            for _ in range(0, len(y)):
                child_nodes = [nodeStack.pop()] + child_nodes
                stateStack.pop()
            nodeStack += [[A, child_nodes]]
            stateStack += [shift_rules_[stateStack[-1], A][1]]
            error_if(not (stateStack[-1], a_) in shift_rules_,
                  "Parse error at token " + a.__str__())

        error_if(not (stateStack[-1], a_) in shift_rules_,
              "Parse error at token " + a.__str__())
        nodeStack += [a]
        stateStack += [(shift_rules_[(stateStack[-1], a_)][1])]

    return nodeStack[1]


def dump_to_xml(parse_tree, parent_node):
    """Returns an XML string representing the parse tree generated by
    parse_token_list"""
    if isinstance(parse_tree, Token):
        token = et.ElementTree.Element("tok_" + parse_tree.type)
        token.text = parse_tree.value
        parent_node.append(token)
        return parent_node

    token_type = parse_tree[0]
    new_parent = et.ElementTree.Element(token_type)
    parent_node.append(new_parent)
    for x in parse_tree[1]:
        dump_to_xml(x, new_parent)
    return parent_node


def parse(tokens, filename):
    """Parses the given file, converts it to an AST, and performs weeding.
    Returns the tree or throws an JoosSyntaxException."""
    parse_tree = parse_token_list(tokens)
    sys.setrecursionlimit(100000)
    tree_root = et.ElementTree.Element("fake_root")
    xml_tree = dump_to_xml(parse_tree, tree_root)[0]
    tree = simplify.simplify_tree(xml_tree)
    weed.weed(tree, filename)
    tree.filename = filename
    return tree


def check(stream, filename):
    """Checks if a stream is lexically and syntactically valid Joos1W code.
    Args:n
        stream: The stream object to check
    Returns:
        0 if the stream is lexically and syntactically valid Joos1W code, 42 if
        the stream is not lexically and syntactically valid Joos1W code."""
    try:
        parse(lexer.lex(stream.read()), filename)
        return 0
    except JoosSyntaxException, e:
        if not Testing.testing:
            print e.msg
        return 42


if __name__ == '__main__':
    sys.exit(check(open(sys.argv[1]), sys.argv[1]))
